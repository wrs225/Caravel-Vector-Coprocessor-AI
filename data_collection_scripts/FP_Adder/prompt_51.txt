
// Add or subtract
always_comb begin
    // Extract fields
    a_sign     = a[31];
    b_sign     = b_neg[31];
    a_exp = a[30:23];
    b_exp = b_neg[30:23];
    a_frac = {1'b1, a[22:0]};  // Add implicit leading 1
    b_frac = {1'b1, b_neg[22:0]};  // Add implicit leading 1

    // Perform addition or subtraction
    if (a_exp > b_exp) begin
        y_exp_intermediate = a_exp;
        if (b_sign) begin
            y_frac_intermediate = a_frac - (b_frac >> (a_exp - b_exp));  // Corrected shift amount
        end else begin
            y_frac_intermediate = a_frac + (b_frac >> (a_exp - b_exp));  // Corrected shift amount
        end
        y_sign = a_sign;
    end else if (a_exp < b_exp) begin
        y_exp_intermediate = b_exp;
        if (b_sign) begin
            y_frac_intermediate = (a_frac >> (b_exp - a_exp)) - b_frac;  // Corrected shift amount
        end else begin
            y_frac_intermediate = (a_frac >> (b_exp - a_exp)) + b_frac;  // Corrected shift amount
        end
        y_sign = b_sign;
    end else begin
        y_exp_intermediate = a_exp;
        if (a_frac >= b_frac) begin
            if (b_sign) begin
                y_frac_intermediate = a_frac - b_frac;  // No shift when exponents are equal
            end else begin
                y_frac_intermediate = a_frac + b_frac;  // No shift when exponents are equal
            end
            y_sign = a_sign;
        end else begin
            if (b_sign) begin
                y_frac_intermediate = b_frac - a_frac;  // No shift when exponents are equal
            end else begin
                y_frac_intermediate = b_frac + a_frac;  // No shift when exponents are equal
            end
            y_sign = b_sign;
        end
    end

    // Normalize result using priority encoder
    if (a == 32'b0 && b == 32'b0) begin
        shift_amount = 5'b00000;  // No shift if both inputs are zero
    end else begin
        shift_amount = y_frac_intermediate[23] ? 5'b00000 : priority_encoder(y_frac_intermediate);
    end

    // Shift fraction and adjust exponent
    y_frac = y_frac_intermediate << shift_amount;
    y_exp = y_exp_intermediate - shift_amount;

    // Handle addition overflow
    if (y_frac[23]) begin
        y_frac = y_frac >> 1;
        y_exp = y_exp + 1;
    end
end

// Pack fields into output
assign y = {y_sign, y_exp, y_frac[22:0]};  // Only take the lower 23 bits of the fraction
Just expand the bitwidth of y_frac_intermediate. After normalizing the result, check to see if there are any ones to the left of the 24th bit of the wire. If there are shift right until the leftmost bit is at the 24th bit of the wire. 
ChatGPT

I apologize for the confusion. Here is the updated code with the normalization logic included:

systemverilog

module fp_addsub (
    input logic [31:0] a,
    input logic [31:0] b,
    input logic subtract,
    output logic [31:0] y
);

    logic [31:0] b_neg;
    logic a_sign, b_sign;
    logic [7:0] a_exp, b_exp;
    logic [23:0] a_frac, b_frac;  // Increase fraction size to 24 bits
    logic y_sign;
    logic [7:0] y_exp;
    logic [23:0] y_frac;  // Increase fraction size to 24 bits
    logic [23:0] y_frac_intermediate;  // Intermediate fraction for normalization
    logic [7:0] y_exp_intermediate;  // Intermediate exponent for normalization
    logic [4:0] shift_amount;  // Shift amount from LUT

    // Negate b if subtract is high
    assign b_neg = subtract ? {b[31]^1'b1, b[30:0]} : b;

    // Add or subtract
    always_comb begin
        // Extract fields
        a_sign     = a[31];
        b_sign     = b_neg[31];
        a_exp = a[30:23];
        b_exp = b_neg[30:23];
        a_frac = {1'b1, a[22:0]};  // Add implicit leading 1
        b_frac = {1'b1, b_neg[22:0]};  // Add implicit leading 1

        // Perform addition or subtraction
        if (a_exp > b_exp) begin
            y_exp_intermediate = a_exp;
            if (b_sign) begin
                y_frac_intermediate = a_frac - (b_frac >> (a_exp - b_exp));  // Corrected shift amount
            end else begin
                y_frac_intermediate = a_frac + (b_frac >> (a_exp - b_exp));  // Corrected shift amount
            end
            y_sign = a_sign;
        end else if (a_exp < b_exp) begin
            y_exp_intermediate = b_exp;
            if (b_sign) begin
                y_frac_intermediate = (a_frac >> (b_exp - a_exp)) - b_frac;  // Corrected shift amount
            end else begin
                y_frac_intermediate = (a_frac >> (b_exp - a_exp)) + b_frac;  // Corrected shift amount
            end
            y_sign = b_sign;
        end else begin
            y_exp_intermediate = a_exp;
            if (a_frac >= b_frac) begin
                if (b_sign) begin
                    y_frac_intermediate = a_frac - b_frac;  // No shift when exponents are equal
                end else begin
                    y_frac_intermediate = a_frac + b_frac;  // No shift when exponents are equal
                end
                y_sign = a_sign;
            end else begin
                if (b_sign) begin
                    y_frac_intermediate = b_frac - a_frac;  // No shift when exponents are equal
                end else begin
                    y_frac_intermediate = b_frac + a_frac;  // No shift when exponents are equal
                end
                y_sign = b_sign;
            end
        end

        // Normalize result using priority encoder
        if (a == 32'b0 && b == 32'b0) begin
            shift_amount = 5'b00000;  // No shift if both inputs are zero
        end else begin
            shift_amount = y_frac_intermediate[23] ? 5'b00000 : priority_encoder(y_frac_intermediate);
        end

        // Shift fraction and adjust exponent
        y_frac = y_frac_intermediate << shift_amount;
        y_exp = y_exp_intermediate - shift_amount;

        // Handle addition overflow
        if (y_frac[23]) begin
            y_frac = y_frac >> 1;
            y_exp = y_exp + 1;
        end
    end

    // Pack fields into output
    assign y = {y_sign, y_exp, y_frac[22:0]};  // Only take the lower 23 bits of the fraction

    // Priority encoder to find the leading one
    function automatic [4:0] priority_encoder (input [23:0] in);
        integer i;
        for (i=23; i>=0; i=i-1) begin
            if (in[i]) begin
                return 23 - i;
            end
        end
        return 5'b00000;  // Return 0 if no one is found
    endfunction
endmodule

In this code, the normalization logic checks if the 23rd bit of y_frac_intermediate is '1'. If it is, it doesn't shift y_frac_intermediate and y_exp_intermediate remains the same. If not, it uses the priority encoder to find the shift amount and shifts y_frac_intermediate left by that amount and subtracts the same amount from y_exp_intermediate. The normalized fraction and exponent are then assigned to y_frac and y_exp respectively. After normalization, the code checks for addition overflow. If the 23rd bit of y_frac is '1', it shifts y_frac right by one and increments y_exp by one.